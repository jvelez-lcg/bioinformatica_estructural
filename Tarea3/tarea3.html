<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />


<meta name="author" content="Salazar Medina Diana, Vélez Santiago Jesús" />


<title>Bioinformática Estructural</title>

<script src="tarea3_files/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="tarea3_files/bootstrap-3.3.5/css/cerulean.min.css" rel="stylesheet" />
<script src="tarea3_files/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="tarea3_files/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="tarea3_files/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="tarea3_files/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="tarea3_files/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="tarea3_files/tocify-1.9.1/jquery.tocify.js"></script>
<script src="tarea3_files/navigation-1.1/tabsets.js"></script>
<link href="tarea3_files/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="tarea3_files/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>


</head>

<body>

<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
  height: auto;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
</style>



<div class="container-fluid main-container">

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  background: white;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open')
  });
});
</script>

<!-- code folding -->



<script>
$(document).ready(function ()  {

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3,h4,h5",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_').toLowerCase();
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}


.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
  padding-left: 25px;
  text-indent: 0;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>

<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row-fluid">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="fluid-row" id="header">



<h1 class="title toc-ignore">Bioinformática Estructural</h1>
<h3 class="subtitle"><em>Tarea 3</em></h3>
<h4 class="author"><em>Salazar Medina Diana, Vélez Santiago Jesús</em></h4>
<h4 class="date"><em>11 de febrero de 2019</em></h4>

</div>


<div id="estructura-terciaria-de-las-proteinas" class="section level2">
<h2>1. Estructura terciaria de las proteínas</h2>
<p>El sigueinte nivel de complejidad es aquel que viene descrito por la representación de las proteínas en el espacio tridimensional. Para continuar indagando sobre la estructura protéica y su modelado se exploró algunos integrantes de la familia de métodos de <strong>Fold Recognition (FR)</strong>, que como dice su nombre, tienen por objeto reconocer el plegamiento que debe asignarsele a una secuencia protéica.</p>
<p><strong>HHpread</strong> es un método de búsqueda de secuencias y predicción de estructura; mucho más sensible para encontrar homólogos remotos, emplea alineamientos de secuencia-perfil o perfil-perfil, los cuales contienen por cada columna de un alineamiento múltiple las frecuencias de los 20 aminoácidos, los cuales guardan valiosa información sobre la conservación de cada posición.[1]</p>
<p>Para nuestra porteína de interés se escogieron dos <em>“moldes”</em> que servirán de guía para modelar la estructura protéica. Una vez realizado el alineamiento se procedió a usar Modeller[2] para hacer un modelado de la estructura terciaria de nuestra proteína.</p>
<div class="figure" style="text-align: center">
<img src="tarea3_files/figure-html/3D_1GKH_Modeller-1.png" alt="**Figure 1.** Tertiary structure of 1 GKH predicted with Modeller." width="672" />
<p class="caption">
<strong>Figure 1.</strong> Tertiary structure of 1 GKH predicted with Modeller.
</p>
</div>
<pre class="bash"><code>head -n 10 ./data/P1_Modeller.pdb</code></pre>
<pre><code>EXPDTA    THEORETICAL MODEL, MODELLER 9.21 2019/01/31 17:33:11
REMARK   6 MODELLER OBJECTIVE FUNCTION:      1306.2444
REMARK   6 MODELLER BEST TEMPLATE % SEQ ID:  98.837
REMARK   6 SEQUENCE: 3099289
REMARK   6 ALIGNMENT: alignment.pir
REMARK   6 SCRIPT: modeller_script.py
REMARK   6 TEMPLATE: 1PFS 2:A - 70:A MODELS 1:X - 80:X AT 20.3%
REMARK   6 TEMPLATE: 1GVP 1:A - 86:A MODELS 1:X - 86:X AT 98.8%
ATOM      1  N   MET X   1       5.800  23.500   6.882  1.00 78.71           N
ATOM      2  CA  MET X   1       4.847  22.563   6.239  1.00 78.71           C</code></pre>
</div>
<div id="evaluacion-de-los-modelos-predichos" class="section level2">
<h2>2. Evaluación de los modelos predichos</h2>
<div id="extraccion-de-angulos-diedros-de-modelo-predicho" class="section level3">
<h3>2.1 Extracción de ángulos diédros de modelo predicho</h3>
<p><code>extract_angles_of_pdb.pl</code> procesa un archivo en formato PDB (<em>Protein Data Bank</em>)[2] para obtener los ángulos diédros (<span class="math inline">\(\phi\)</span>, <span class="math inline">\(\psi\)</span> y <span class="math inline">\(\omega\)</span>) de cada residuo protéico y de esta forma porder representarlos en un <em>diagrama de Ramachandran</em> y clasificar los aminoácidos según su localiación en el gráfico.</p>
<p><details><summary>Mostrar código</summary></p>
<pre class="perl"><code>#!/usr/bin/perl -w

# prog2.2 calcula los angulos diedros de una proteina en formato PDB
# Bruno Contreras-Moreira, adaptado de http://praveenvijay.netfirms.com/scripts.htm#backbone

use strict;
use Math::Trig;

my ($PDBfile,@coordenadas,@atomo,@residuo,@cadena,@res_id,@x,@y,@z);
my ($total,$j,$i) = (0,1);

if(!$ARGV[0]){ die &quot;# usage: $0 &lt;PDB file&gt;\n&quot;; }
else{ $PDBfile = $ARGV[0] }

## 1) lee coordenadas atomicas en formato PDB
open(PDB,$PDBfile)|| die &quot;# $0 : no puedo leer $PDBfile\n&quot;;
while(&lt;PDB&gt;)
{
    last if(/^ENDMDL/); # para estructuras NMR como 1lfu, TER es otra opcion
    next if not(/^ATOM\s+\d+\s+(?:N|CA|C)\s+/);
    push(@coordenadas,$_);
}
close(PDB);

## 2) recorre secuencia buscando atomos N,CA,C consecutivos
for $i (0..$#coordenadas-2)
{
    #ATOM   2231  N   ALA P  78     -14.689   7.253 -23.476
    $residuo[$j] = substr($coordenadas[$i],17,3);
    $cadena[$j] = substr($coordenadas[$i],21,1);
    $res_id[$j]  = substr($coordenadas[$i],23,3);
    $atomo[$j]   = substr($coordenadas[$i],12,4);
    $atomo[$j+1] = substr($coordenadas[$i+1],12,4);
    $atomo[$j+2] = substr($coordenadas[$i+2],12,4); 

    if($atomo[$j] eq &#39; N  &#39; &amp;&amp; $atomo[$j+1] eq &#39; CA &#39; &amp;&amp; $atomo[$j+2] eq &#39; C  &#39;)
    {
        $x[$j]{&#39;N&#39;} = substr($coordenadas[$i],30,8);   
        $y[$j]{&#39;N&#39;} = substr($coordenadas[$i],38,8);   
        $z[$j]{&#39;N&#39;} = substr($coordenadas[$i],46,8);   
                                                               
        $x[$j]{&#39;CA&#39;} = substr($coordenadas[$i+1],30,8);
        $y[$j]{&#39;CA&#39;} = substr($coordenadas[$i+1],38,8);
        $z[$j]{&#39;CA&#39;} = substr($coordenadas[$i+1],46,8); 

        $x[$j]{&#39;C&#39;} = substr($coordenadas[$i+2],30,8); 
        $y[$j]{&#39;C&#39;} = substr($coordenadas[$i+2],38,8);
        $z[$j]{&#39;C&#39;} = substr($coordenadas[$i+2],46,8);
        $j++;
        $total++;
    }
}
print &quot;# $0 : fichero PDB: $PDBfile ($total residuos)\n&quot;;

## 3) calcula e imprime angulos diedros
print &quot;num\tresiduo\tphi\tpsi\tomega\n&quot;;
for $j (2..$total-1)
{ 
    my ($x1,$y1,$z1,$x2,$y2,$z2,$x3,$y3,$z3,$x4,$y4,$z4,$x5,$y5,$z5,$x6,$y6,$z6); # puntos
    my (@v1,@v2,@v3,@v4,@v5,@v6,@v7,@v8);        # vectores directores
    my ($phi,$psi,$omega) = (-9999,-9999,-9999); # valores nulos por defecto

    # toma atomos en residuos j-1,j y j+1 para definir planos y calcular angulos diedros
    ($x1,$y1,$z1) = ( $x[$j-1]{&#39;C&#39;} , $y[$j-1]{&#39;C&#39;} , $z[$j-1]{&#39;C&#39;} ); 
    ($x2,$y2,$z2) = ( $x[$j]{&#39;N&#39;}   , $y[$j]{&#39;N&#39;}   , $z[$j]{&#39;N&#39;} );   # Cj-1 - Nj 
    ($x3,$y3,$z3) = ( $x[$j]{&#39;CA&#39;}  , $y[$j]{&#39;CA&#39;}  , $z[$j]{&#39;CA&#39;} );  #         \
    ($x4,$y4,$z4) = ( $x[$j]{&#39;C&#39;}   , $y[$j]{&#39;C&#39;}   , $z[$j]{&#39;C&#39;} );   #         CAj - Cj
    ($x5,$y5,$z5) = ( $x[$j+1]{&#39;N&#39;} , $y[$j+1]{&#39;N&#39;} , $z[$j+1]{&#39;N&#39;} ); #                \ 
    ($x6,$y6,$z6) = ( $x[$j+1]{&#39;CA&#39;}, $y[$j+1]{&#39;CA&#39;}, $z[$j+1]{&#39;CA&#39;} );#                 Nj+1 - CAj+1

    @v1 = ( $x2-$x1 , $y2-$y1 , $z2-$z1 ); # plano definido por Cj-1, Nj and CAj (para medir phi)
    @v2 = ( $x3-$x1 , $y3-$y1 , $z3-$z1 );

    @v3 = ( $x3-$x2 , $y3-$y2 , $z3-$z2 ); # plano Nj, CAj and Cj (para medir phi y psi)
    @v4 = ( $x4-$x2 , $y4-$y2 , $z4-$z2 );
    
    @v5 = ( $x4-$x3 , $y4-$y3 , $z4-$z3 ); # plano CAj, Cj and Nj+1 (para medir psi)
    @v6 = ( $x5-$x3 , $y5-$y3 , $z5-$z3 );

    @v7 = ( $x5-$x4 , $y5-$y4 , $z5-$z4 ); # plano Cj, Nj+1 and CAj+1 (para medir psi y omega)
    @v8 = ( $x6-$x4 , $y6-$y4 , $z6-$z4 );

    $phi = angulo_diedro( @v1, @v2, @v3, @v4, $x3, $y3, $z3, $x2, $y2, $z2 );  # entre Nj y CAj (2Cs)
    $psi = angulo_diedro( @v3, @v4, @v5, @v6, $x4, $y4, $z4, $x3, $y3, $z3 );  # entre CAj y Cj (2Ns)
    $omega = angulo_diedro( @v5, @v6, @v7, @v8, $x5, $y5, $z5, $x4, $y4, $z4 );# entre Nj+1 y Cj (2CAs)

    print join(&quot;\t&quot;,($res_id[$j],join(&quot; &quot;,$residuo[$j],$cadena[$j]),$phi,$psi,$omega)) . &quot;\n&quot;;
    #printf(&quot;%4d
    # %3s %s %8.1f %8.1f %8.1f\n&quot;,$res_id[$j],$residuo[$j],$cadena[$j],$phi,$psi,$omega);
}
#print &quot;#  residuo      phi      psi    omega\n&quot;;

sub angulo_diedro 
{
    my (@p) = @_; #parametros ( v_plano1,v_plano2, v_plano3, v_plano4, enlace1, enlace2 )
    
    my (@v1,@v2,$modulo1,$modulo2,$prod_escalar,@normal,$cos,$ang,$signo);

    ## 1) determina el angulo entre ambos planos
    # calcula vector perpendicular a cada plano por producto vectorial
    @v1 = ( ($p[1]*$p[5])-($p[2]*$p[4])     , ($p[2]*$p[3])-($p[0]*$p[5])     , ($p[0]*$p[4])-($p[3]*$p[1]) );
    @v2 = ( ($p[7]*$p[11])-($p[8]*$p[10]) , ($p[8]*$p[9])-($p[6]*$p[11]) , ($p[6]*$p[10])-($p[9]*$p[7]) );

    # calcula producto escalar de vectores perpendiculares para estimar cos(angulo)
    $prod_escalar = ($v1[0]*$v2[0]+$v1[1]*$v2[1]+$v1[2]*$v2[2]);
    $modulo1 = ((($v1[0]*$v1[0])+($v1[1]*$v1[1])+($v1[2]*$v1[2]))**0.5);
    $modulo2 = ((($v2[0]*$v2[0])+($v2[1]*$v2[1])+($v2[2]*$v2[2]))**0.5);    
    $cos = ($prod_escalar/($modulo1*$modulo2));
    $ang = (Math::Trig::acos($cos))/(Math::Trig::pi/180);
    
    ## 2) determina el signo del angulo diedro
    # calcula vector normal a ambos vectores perpendiculares por producto vectorial
    @normal = ( ($v1[1]*$v2[2])-($v1[2]*$v2[1]) , ($v1[2]*$v2[0])-($v1[0]*$v2[2]) , ($v1[0]*$v2[1])-($v1[1]*$v2[0]) );
    
    # calcula producto escalar de vector normal y vector del enlace donde se da el angulo
    $signo = ((($p[12]-$p[15])*($normal[0]))+(($p[13]-$p[16])*($normal[1]))+(($p[14]-$p[17])*($normal[2])));
    if($signo &lt; 0){ $ang=-$ang } # agudo si es positivo
    
    return $ang;
}</code></pre>
<p></details></p>
<pre class="bash"><code>perl ./code/extract_angles_of_pdb.pl ./data/P1_Modeller.pdb &gt; ./data/P1_modeller.tsv</code></pre>
</div>
<div id="asignacion-de-categoria-a-cada-residuo-por-archivo-de-angulos." class="section level3">
<h3>2.2 Asignación de categoria a cada residuo por archivo de ángulos.</h3>
<pre class="r"><code>library(tidyverse)
protein_name &lt;- &quot;1GKH&quot;
angle_file1 &lt;- &quot;./data/angles.tsv&quot;
angle_file2 &lt;- &quot;./data/P1_Modeller.tsv&quot;

angles_files &lt;- c(angle_file1,angle_file2)
proccedences &lt;- c(&quot;Original PDB&quot;, &quot;Modeller&quot;)

angle_data &lt;- map2(angles_files, proccedences, .f = function(angle_file,proccedence){
    read_tsv(angle_file, comment = &quot;#&quot;) %&gt;% mutate(
      category  = case_when(
        (phi &lt; 0 &amp; psi &lt; 0) ~ &quot;H&quot;,
        (phi &lt; 0 &amp; psi &gt; 0) ~ &quot;E&quot;,
        TRUE ~ &quot;C&quot;  
      ), 
      category2  = case_when(
      (phi &gt;= -135 &amp; phi &lt;= -50 &amp; psi &gt;= -70 &amp; psi &lt;= 40 ) ~ &quot;H&quot;,
      (phi &gt;= -170 &amp; phi &lt;= -45 &amp; psi &gt; 90) ~ &quot;E&quot;,
      TRUE ~ &quot;C&quot;  
      ),
      proccedence = factor(proccedence, levels = proccedences))
  }) %&gt;% bind_rows()</code></pre>
</div>
<div id="grafico-de-ramachandran" class="section level3">
<h3>2.3 Gráfico de Ramachandran</h3>
<div id="definido-por-cuadrantes" class="section level4">
<h4>2.3.1 Definido por cuadrantes</h4>
<pre class="r"><code>ggplot(angle_data, aes(phi,psi, color = category)) +
  geom_point() +
  geom_density_2d() +
  xlab(expression(phi(theta))) +
  ylab(expression(psi(theta))) +
  ggtitle(paste0(&quot;Ramachandran Plot of &quot;, protein_name)) +
  theme(plot.title = element_text(hjust = 0.5)) +
  scale_x_continuous(limits = c(-180, 180), breaks = c(-180, -90, 0, 90, 180)) +
  scale_y_continuous(limits = c(-180, 180), breaks = c(-180, -90, 0, 90, 180)) +
  facet_wrap(~ proccedence)</code></pre>
<p><img src="tarea3_files/figure-html/ramachandran_cuadrantes-1.png" width="672" style="display: block; margin: auto;" /></p>
</div>
<div id="definido-por-rectanculos-cercanos-a-zonas-de-betas-y-alphas" class="section level4">
<h4>2.3.2 Definido por rectánculos cercanos a zonas de <span class="math inline">\(\beta\)</span>s y <span class="math inline">\(\alpha\)</span>s</h4>
<pre class="r"><code>ggplot(angle_data, aes(phi,psi, color = category2)) +
  geom_point() +
  geom_density2d(aes(phi,psi), data = filter(angle_data, category2 != &#39;C&#39;)) +
  xlab(expression(phi(theta))) +
  ylab(expression(psi(theta))) +
  ggtitle(paste0(&quot;Ramachandran Plot of &quot;, protein_name)) +
  theme(plot.title = element_text(hjust = 0.5)) +
  scale_x_continuous(limits = c(-180, 180), breaks = c(-180, -90, 0, 90, 180)) +
  scale_y_continuous(limits = c(-180, 180), breaks = c(-180, -90, 0, 90, 180)) +
  facet_wrap(~proccedence)</code></pre>
<p><img src="tarea3_files/figure-html/ramachandran_deifnito-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>Como se observa en las gráficas, en la estructura predicha por Modeller, los resiudos de <span class="math inline">\(\beta\)</span>-sheets y <span class="math inline">\(\alpha\)</span>-hélices parecen estar más concentrados respecto a la estructura original.</p>
</div>
</div>
</div>
<div id="calculando-superposiciones-con-mammoth" class="section level2">
<h2>3. Calculando superposiciones con MAMMOTH:</h2>
<div id="ejecucion" class="section level3">
<h3>3.1 Ejecución</h3>
<p>Se ejecuta la siguiente línea en el servidor:</p>
<pre class="bash"><code>mammoth -p P1_Modeller.pdb -e P1.pdb -o P1_mammoth_evaluation.txt</code></pre>
</div>
<div id="salida" class="section level3">
<h3>3.2 Salida</h3>
<pre class="bash"><code>cat ./data/P1_mammoth_evaluation.txt</code></pre>
<pre><code> Predicted path:   
 Experimental path:
 _______________________________________________________________________________

                                M  A  M  M  O  T  H

               MAtching Molecular Models Obtained from THeory

 _______________________________________________________________________________

  
 -------------------
  Input information 
 -------------------
  

==&gt; PREDICTION: 

     Filename: P1_Modeller.pdb
     Number of residues:    86


==&gt; EXPERIMENT: 

     Filename: P1.pdb
     Number of residues:    86

  
 -----------------------------
  Structural Alignment Scores 
 -----------------------------
  
 
 PSI(ini)=   98.84  NALI=  85  NORM=  86  RMS=    0.82  NSS=  79
 PSI(end)=   98.84  NALI=  85  NORM=  86  RMS=    0.82
 Sstr(LG)= 1635.61  NALI=  85  NORM=  86  RMS=    0.82
 
E-value=     0.26203033E-05
 
Z-score=      13.276863        -ln(E)=      12.852220    
  
 ----------------------------
  Final Structural Alignment 
 ----------------------------
  
           ********** ********** ********** ********** **********
Prediction MIKVEIKPSQ AQFTTRSGVS RQGKPYSLNE QLCYVDLGNE YPVLVKITLD
Prediction SSSSSSS--S SSSSSSSSS- ----SSSSSS SSSSSS---- -SSSSSSSS-
           |||||||||| |||||||||| |||||||||| |||||||||| ||||||||||
Experiment SSSSSSS--S SSSSSSSSS- ----SSSSSS SSSSSS---- -SSSSSSSS-
Experiment MIKVEIKPSQ AQFTTRSGVS RQGKPYSLNE QLCYVDLGNE YPVLVKITLD
           ********** ********** ********** ********** **********
  
           ********** ********** ********** *****
Prediction EGQPAYAPGL YTVHLSSFHV GQFGSLMIDR LRLVP
Prediction ---SSS---- SSSSSSSSSS -----SSSSS SSSSS
           |||||||||| |||||||||| |||||||||       
Experiment ---SSS---- SSSSSSSSSS -----SSSSS SSSSS
Experiment EGQPAYAPGL YTVHLSSFHV GQFGSLMIDR LRLVP
           ********** ********** ********** *****
  
  
 ---------
  Timings 
 ---------
  
   &lt; Initialization:                      0.010 sec &gt;
   &lt; Secondary Structure assignment       0.000 sec &gt;
   &lt; Structure alignment:                 0.010 sec &gt;
   &lt; Tertiary structure matching:         0.000 sec &gt;
   &lt; Text Output                          0.000 sec &gt;
  
&lt;MAMMOTH&gt; NORMAL_EXIT</code></pre>
<p>El <span class="math inline">\(E-value\)</span> es pequeño por lo que los resultados parecen no estar siendo producto del azar. Además de que el valor de que el valor de <span class="math inline">\(RMSD\)</span> es menor a 3 lo que indica que el modelo predicho tiene un buen ajuste.</p>
</div>
</div>
<div id="evaluando-las-estructuras-con-tmalign" class="section level2">
<h2>4. Evaluando las estructuras con TMalign:</h2>
<p>“TM-align is an algorithm for sequence independent protein structure comparisons. For two protein structures of unknown equivalence, TM-align first generates optimized residue-to-residue alignment based on structural similarity using dynamic programming iterations. An optimal superposition of the two structures, as well as the TM-score value which scales the structural similarity, will be returned. TM-score has the value in (0,1], where 1 indicates a perfect match between two structures. Following strict statistics of structures in the PDB, scores below 0.2 corresponds to randomly chosen unrelated proteins whereas with a score higher than 0.5 assume generally the same fold in SCOP/CATH. Por lo que se observa parace que tenemos un buen plegamiento.”[3]</p>
<div id="ejecucion-1" class="section level3">
<h3>4.1 Ejecución</h3>
<p>Se ejecuto la siguiente línea en la computadora local:</p>
<pre class="bash"><code>./TMalign/TMalign ./data/P1.pdb ./data/P1_Modeller.pdb &gt; ./data/TMscore.txt</code></pre>
</div>
<div id="salida-1" class="section level3">
<h3>4.2 Salida</h3>
<pre class="bash"><code>cat ./data/TMscore.txt</code></pre>
<pre><code>
 *****************************************************************************
 * TM-align (Version 20160521): A protein structural alignment algorithm     *
 * Reference: Y Zhang and J Skolnick, Nucl Acids Res 33, 2302-9 (2005)       *
 * Please email your comments and suggestions to Yang Zhang (zhng@umich.edu) *
 *****************************************************************************

Name of Chain_1: ./data/P1.pdb (to be superimposed onto Chain_2)
Name of Chain_2: ./data/P1_Modeller.pdb
Length of Chain_1: 86 residues
Length of Chain_2: 86 residues

Aligned length= 86, RMSD=   0.82, Seq_ID=n_identical/n_aligned= 1.000
TM-score= 0.94846 (if normalized by length of Chain_1, i.e., LN=86, d0=3.33)
TM-score= 0.94846 (if normalized by length of Chain_2, i.e., LN=86, d0=3.33)
(You should use TM-score normalized by length of the reference protein)

(&quot;:&quot; denotes residue pairs of d &lt;  5.0 Angstrom, &quot;.&quot; denotes other aligned residues)
MIKVEIKPSQAQFTTRSGVSRQGKPYSLNEQLCYVDLGNEYPVLVKITLDEGQPAYAPGLYTVHLSSFHVGQFGSLMIDRLRLVPA
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
MIKVEIKPSQAQFTTRSGVSRQGKPYSLNEQLCYVDLGNEYPVLVKITLDEGQPAYAPGLYTVHLSSFHVGQFGSLMIDRLRLVPA


Total running time is  0.01 seconds</code></pre>
<p>Los resultados parecen indicar que la comparación de estructuras ha sido buena (i.e. mayor que 0.5) lo que se podría explicar ya que los moldes utilizados para contruir el modelo predicho pertenecen a estructuras proteícas de la misma familia que la proteína de interés.</p>
</div>
</div>
<div id="referencias" class="section level2">
<h2>5. Referencias</h2>
<p>[1]A Completely Reimplemented MPI Bioinformatics Toolkit with a New HHpred Server at its Core. Zimmermann L, Stephens A, Nam SZ, Rau D, K?bler J, Lozajic M, Gabler F, S?ding J, Lupas AN, Alva V. J Mol Biol. 2018 Jul 20. S0022-2836(17)30587-9.</p>
<p>[2] A Completely Reimplemented MPI Bioinformatics Toolkit with a New HHpred Server at its Core. Zimmermann L, Stephens A, Nam SZ, Rau D, K?bler J, Lozajic M, Gabler F, S?ding J, Lupas AN, Alva V. J Mol Biol. 2018 Jul 20. S0022-2836(17)30587-9.</p>
<p>[3] <a href="https://zhanglab.ccmb.med.umich.edu/TM-align/" class="uri">https://zhanglab.ccmb.med.umich.edu/TM-align/</a></p>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
